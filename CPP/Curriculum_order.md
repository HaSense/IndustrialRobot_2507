# C++ 커리큘럼 설계: C를 배운 학생을 위한 최적화된 교육 로드맵

이 문서는 **C 경험이 있는 학생이 C++을 깊이 있게 이해하도록 유도하는 7단계 학습 로드맵**이다.  
핵심 철학은 “C++은 C의 확장이 아니라 **추상화와 안전성을 제공하는 또 다른 패러다임의 언어**”라는 점을 명확히 인식시키는 것이다.

---

# 1단계: C와 C++의 철학적 차이 소개

학생은 먼저 “C++이 왜 필요한가”를 이해해야 한다.  
이 단계가 정립되지 않으면 이후에 STL, 클래스, 상속을 배워도 “왜 이렇게 복잡하게 쓰지?”라는 반발감을 갖게 된다.

## 핵심 개념
- **C++은 C의 단순 확장이 아니다.**
- **추상화(abstraction)** 중심 언어  
  → 데이터 + 행동을 하나의 객체로 묶는다.
- **RAII(Resource Acquisition Is Initialization)**  
  → 생성과 동시에 자원을 획득하고, 소멸자로 안전하게 반환
- **메모리 관리 패러다임 변화**
  - C: malloc/free, new/delete
  - C++: smart pointer + RAII
- **헤더와 구현 분리 규율(header/impl)**  
  → 캡슐화 및 빌드 구조 정립

## 이 단계의 목표
- “C++은 왜 클래스가 필요한가?”
- “C에서 가능하던 것을 왜 더 복잡하게 변환하는가?”
- “안전성과 확장성을 얻기 위해서다.”

---

# 2단계: iostream + 기본 class 문법 (1~2회차)

학생이 가장 먼저 배우는 실질적 C++ 문법 단계.

## 학습 요소
- `iostream` 기반 입출력
- `string` 클래스 익히기
- `struct → class` 개념 전환
- **생성자/소멸자**
- 멤버함수, private/public
- `this` 포인터(심화 X)

## 교육 목적
- “C 구조체와 C++ 클래스는 완전히 다르다”는 감을 얻게 한다.
- 데이터 + 행동 결합 개념에 적응시키기.

---

# 3단계: 소규모 OOP 구조 만들기 (1회차)

상속을 배우기 전에 반드시 **클래스를 여러 개 만들어보는 경험**이 필요하다.

## 예제 프로젝트 (텍스트 RPG)
- `Player` 클래스
- `Monster` 클래스
- `Item` 클래스

각 객체의 행동 구현:  
- attack(), defend(), useItem() 등

## 교육 목적
- 클래스 간 관계를 “몸으로 익히게” 하는 단계
- 상속이 “문법” 아니라 “설계 개선”임을 직관적으로 이해하도록 준비

---

# 4단계: 상속과 다형성 (1~2회차)

이제 상속을 도입해도 학생들의 기반이 준비되어 있다.

## 학습 내용
- 상속 구문
- 가상 함수 (`virtual`)
- 재정의 (`override`)
- 동적 바인딩
- 순수 가상 함수 / 인터페이스

## 추천 예제
- `Animal → Dog, Cat`
- `Enemy → Orc, Goblin`

## 교육 목적
- 다형성이 “코드 확장성을 위한 도구”임을 체감하도록 유도

---

# 5단계: 스마트포인터 + RAII (1회차)

여기에서 smart pointer를 가르치는 것이 **가장 이상적인 타이밍**이다.

## 학습 개념
- RAII
- `std::unique_ptr`
- `std::shared_ptr`
- `std::weak_ptr`
- `std::make_unique` / `std::make_shared`
- **객체 소유권 모델 (ownership model)**

## 왜 이 단계인가?
- 상속/객체 구조를 경험한 뒤라서  
  → “객체 수명 관리”의 필요성을 체감한다.
- STL을 배우기 전에 반드시 필요  
  → vector<string*> 같은 나쁜 코드 방지

---

# 6단계: STL Containers + Algorithms (2~3회차)

이제 학생은 충분한 기반을 갖고 있으므로 STL이 매우 효과적이고 자연스럽게 이해된다.

## 추천 순서
1. `vector`
2. `string`
3. `map`, `unordered_map`
4. `algorithm` 핵심 함수  
   - sort  
   - find / find_if  
   - transform  
   - for_each  
5. iterator 개념

## 교육 목적
- “STL은 안전하고 검증된 고품질 라이브러리”라는 점을 체험하게 한다.
- 수동 배열 / 수동 linked list가 왜 비효율적인지 자연스럽게 알게 됨.

---

# 7단계: 템플릿 / 예외 / 연산자 오버로딩 등 “필요 최소 문법” (정리 파트)

본 단계는 부가적인 문법이므로 최소만 다룬다.

## 다룰 문법 목록
### **템플릿**
- 함수 템플릿 정도만
- 클래스 템플릿은 STL 분석 수준까지만

### **연산자 오버로딩**
- `operator<<` (출력 오버로딩)
- `operator[]` (배열형 객체)

### **예외 처리**
- `try/catch`
- 예외 안전성 기본 원칙

### **const correctness**
- 반드시 필요한 주제  
  (유효성, 안정성, 오류 방지에 반드시 필요)

### **namespace**
- C++ 라이브러리 구조 이해 수준으로만

## 교육 목적
- 불필요한 어려운 문법에 시간을 낭비하지 않게 한다.
- 핵심 로직과 큰 그림을 먼저 잡도록 설계한다.

---

# 결론: 최적 학습 순서 요약
1. C vs C++ 철학 / RAII / 추상화

2. iostream + 기본 class 문법

3. 클래스 여러 개로 작은 OOP 구조 만들기

4. 상속 + 다형성

5. 스마트포인터 + Ownership

6. STL Containers + Algorithms

7. 템플릿 / 예외 / 오버로딩 / const 등 보충 문법
